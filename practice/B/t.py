Алгоритм работает за O(|preperiod| + |period|) времени и O(1) памяти.
Находим такую степень 2, которая больше и предпериода, и периода. Пусть текущая степень равна k. Если f^k(0) встречается среди значений f^(k+1)(0) ... f^(2 * k)(0), и f^k(0) == f^(k+T)(0), тогда элементы k и k + T находятся в цикле, то есть k не меньше предпериода и k не меньше периода T. Эта часть работает за O(|preperiod| + |period|).
Вторая часть находит длину предпериода, то есть номер первого элемента, который находится "не в цикле", то есть f^k(0) != f^(k + T)(0), работает так же за линейное время.

T = None
k = 1

while not T:
    k *= 2
    x = 0
    for i in range(k):
        x = f(x)
    x0 = x
    T = None
    for i in range(k):
        x = f(x)
        if x == x0:
            T = i
            break
xT = 0
for i in range(T):
    xT = f(xT)

x = 0
preperiod = 0
while x != xT:
    x = f(x)
    xT = f(xT)
    preperiod += 1

print "Preperiod", preperiod, "period", T

